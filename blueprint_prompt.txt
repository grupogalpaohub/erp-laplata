ğŸ§  SYSTEM PROMPT â€” ERP La Plata (Fiori-like, Next 14 + Supabase, Vercel Ready)

Implemente um ERP/CRM modular (MM/WH, SD, CRM, FI, CO) com telas de Setup/Customizing.
Stack: Next.js 14 (App Router, React + TS) + Tailwind + Supabase (DB/Auth/Edge Functions) + Vercel.
RepositÃ³rio: erp-laplata, branches: erp-prod (produÃ§Ã£o), erp-dev (desenvolvimento), erp-git (integraÃ§Ã£o).

Regras globais (obrigatÃ³rias)

Multi-tenant: toda tabela tem tenant_id (text). MVP usa LaplataLunaria.

Planta/DepÃ³sito: plant_id (warehouse). Exatamente 1 is_default=true por tenant (constraint Ãºnica parcial).

Moeda: valores em centavos (integer).

Datas: date ou timestamptz conforme indicado.

RLS: todas as tabelas com policies por tenant_id. Leituras/escritas sÃ³ do tenant atual.

NumeraÃ§Ã£o: usar doc_numbering (nÃ£o hardcode). FunÃ§Ã£o atÃ´mica next_doc_number.

Sistema de IDs Sequenciais: TODOS os registros principais devem ter IDs Ãºnicos e sequenciais:

ID de Materiais: prefixo baseado no tipo (B_ para Brincos, G_ para Gargantilhas, C_ para CordÃµes, A_ para AnÃ©is, P_ para Pulseiras, Ch_ para Chokers, K_ para Kits). Formato: PREFIXO_NUMERO (ex: B_001, G_184).

ID de Fornecedores: SUP_00001, SUP_00002... (sequencial) ou V1234567890 (timestamp-based).

ID de Pedidos de Compra: PO-000001, PO-000002... (sequencial) ou PO-YYYYMM-SEQ6 (com data).

ID de Pedidos de Venda: SO-YYYYMM-SEQ6 (ex: SO-202501-000001) via next_doc_number().

ID de Clientes: CUST-1234567890 (timestamp-based) ou CUST-YYYYMM-SEQ6 (com data).

ID de DepÃ³sitos: WH-001, WH-002... (sequencial) ou PLANT-001, PLANT-002...

ID de LanÃ§amentos Financeiros: FI-YYYYMM-SEQ6, PAY-YYYYMM-SEQ6, REC-YYYYMM-SEQ6...

ID de MovimentaÃ§Ãµes de Estoque: MOV-YYYYMM-SEQ6, ENT-YYYYMM-SEQ6, SAI-YYYYMM-SEQ6...

GeraÃ§Ã£o AutomÃ¡tica: Implementar lÃ³gica de geraÃ§Ã£o sequencial para TODOS os mÃ³dulos, com validaÃ§Ã£o de unicidade e fallback para timestamp em caso de conflito.

Auth: Supabase Auth (e-mail/password). user_profile.user_id Ã© o UUID do Supabase.

Service Role: apenas nas Edge Functions. Front usa sÃ³ NEXT_PUBLIC_SUPABASE_ANON_KEY.

UI: Fiori-like â€” sidebar fixa, header com busca global, 4 KPIs comparativos no topo, tiles por mÃ³dulo.

AderÃªncia a Free Tier: consultas paginadas, Ã­ndices mÃ­nimos, nenhuma funÃ§Ã£o com loops pesados, snapshots de KPI assÃ­ncronos e com caching (detalhes no fim).

KPIs de topo (linha de 4 cards)

Pedidos Hoje â€” subtÃ­tulo: â€œMÃ©dia diÃ¡ria do mÃªsâ€.

Receita do MÃªs â€” subtÃ­tulo: â€œMÃ©dia mensal histÃ³ricaâ€.

Leads Ativos (semana) â€” subtÃ­tulo: â€œMÃ©dia mensalâ€.

Estoque CrÃ­tico (itens) â€” subtÃ­tulo: â€œPNs crÃ­ticos Â· TendÃªncia de consumoâ€.

Renderizar como <KpiCard title value comparisonText trend? />.

ğŸ“ Estrutura do projeto
erp-laplata/
â”œâ”€ frontend/                     # Next 14
â”‚  â”œâ”€ src/app/(routes)/
â”‚  â”‚  â”œâ”€ launchpad/
â”‚  â”‚  â”œâ”€ co|mm|sd|wh|crm|fi/     # mÃ³dulos
â”‚  â”‚  â””â”€ setup/(co|mm|sd|wh|crm|fi)/
â”‚  â”œâ”€ src/components/            # KpiCard, ModuleTile, DataTable, forms
â”‚  â””â”€ src/lib/supabase.ts
â”œâ”€ supabase/
â”‚  â”œâ”€ migrations/                # DDL + RLS + triggers
â”‚  â”œâ”€ seed/                      # seeds iniciais (customizings + dados mÃ­nimos)
â”‚  â””â”€ functions/                 # Edge Functions (setup, po/so, kpi)
â””â”€ docs/BLUEPRINT_CURSOR.md      # este arquivo

ğŸ”Œ VariÃ¡veis de ambiente (Cloudflare Pages â†’ Project Settings)

NEXT_PUBLIC_APP_NAME = ERP Laplata

NEXT_PUBLIC_SUPABASE_URL = <url do projeto>

NEXT_PUBLIC_SUPABASE_ANON_KEY = <anon key>

(Edge Functions) SUPABASE_SERVICE_ROLE_KEY (apenas no backend, jamais no front)

Build:

Root dir: /

Build command: cd frontend && npm install && npm run build

Output dir: frontend/out

next.config.js com output: 'export' + images.unoptimized = true.

ğŸ¨ UI & NavegaÃ§Ã£o

Sidebar com mÃ³dulos (CO, MM, SD, WH, CRM, FI, Analytics).

Launchpad: tiles por mÃ³dulo (Central, Dashboard, Setup, Criar Documento).

Form padrÃ£o (shadcn + zod), tabelas com paginaÃ§Ã£o server-side (TanStack Query).

PermissÃµes: use role_permission para ocultar aÃ§Ãµes/botÃµes (alÃ©m de RLS no banco).

ğŸ—„ï¸ Banco de dados â€” Tabelas (MVP)

Todas as tabelas possuem tenant_id text. Chaves: simples ou compostas conforme indicado.
Aqui vai o catÃ¡logo mÃ­nimo para o ERP funcionar ponta a ponta (dados + customizings).

ğŸ” Setup & SeguranÃ§a

tenant: tenant_id(PK), display_name, locale, timezone, created_at

user_profile: tenant_id, user_id(PK), name, email, role, is_active, created_at

role_permission: tenant_id, role, resource, action, allowed

app_setting: tenant_id, key, value, updated_at

doc_numbering: tenant_id, doc_type, prefix, format, next_seq, is_active

audit_log: tenant_id, audit_id, table_name, record_pk, action, diff_json, actor_user, created_at

import_job/import_log: logs de importaÃ§Ã£o (bootstrap/seeds)

ğŸ“¦ MM â€” Materiais & Fornecedores (negÃ³cio)

mm_vendor: tenant_id, vendor_id(PK), vendor_name, email, telefone, cidade, estado, vendor_rating

mm_material: tenant_id, mm_material(PK), mm_comercial, mm_desc, mm_mat_type, mm_mat_class, mm_price_cents, barcode, weight_grams, status, mm_pur_link, mm_vendor_id?

mm_purchase_order: tenant_id, mm_order(PK), vendor_id, status, po_date, expected_delivery?, notes?

mm_purchase_order_item: tenant_id, po_item_id(PK), mm_order, plant_id, mm_material, mm_qtt numeric, unit_cost_cents, line_total_cents, notes?

mm_receiving: tenant_id, recv_id(PK), mm_order, plant_id, mm_material, qty_received numeric, received_at timestamptz

ğŸ­ WH â€” DepÃ³sitos & Estoque (negÃ³cio)

wh_warehouse: tenant_id, plant_id(PK), name, is_default boolean (UNIQUE por tenant onde true)

wh_inventory_balance: tenant_id, plant_id, mm_material, on_hand_qty numeric, reserved_qty numeric (PK composta tenant_id, plant_id, mm_material)

wh_inventory_ledger (opcional no MVP, recomendado): ledger_id bigserial(PK), tenant_id, plant_id, mm_material, movement (IN|OUT|RESERVE|RELEASE|ADJUST), qty numeric, ref_type, ref_id, created_at

ğŸ›’ SD â€” Vendas (negÃ³cio)

crm_customer: tenant_id, customer_id(PK), name, email?, telefone?, customer_type(PF|PJ), status, created_date

sd_sales_order: tenant_id, so_id(PK), customer_id, status, order_date, expected_ship?, total_cents

sd_sales_order_item: tenant_id, so_id, sku, quantity, unit_price_cents, line_total_cents (PK composta tenant_id, so_id, sku, row_no? se precisar)

sd_shipment: tenant_id, shipment_id(PK), so_id, warehouse_id, ship_date, status, carrier?, tracking_code?

sd_payment: tenant_id, payment_id(PK), so_id, amount_cents, payment_date, payment_method, status

ğŸ§² CRM â€” Leads & Oportunidades (negÃ³cio)

crm_lead: tenant_id, lead_id(PK), name, email?, phone?, source, status, score?, owner_user?, created_date

crm_opportunity: tenant_id, opp_id(PK), lead_id, stage, est_value_cents?, probability?, next_action_at?, status, created_date

crm_interaction: tenant_id, interaction_id(PK), lead_id, channel, content, sentiment?, created_date

ğŸ’° FI â€” Financeiro (negÃ³cio)

fi_account: tenant_id, account_id(PK), name, type(caixa|banco), currency, is_active

fi_invoice: tenant_id, invoice_id(PK), source_type(PO|SO), source_id, customer_id?, vendor_id?, amount_cents, due_date, status, created_date

fi_payment: tenant_id, payment_id(PK), invoice_id, account_id, amount_cents, payment_date, method, status

fi_transaction: tenant_id, transaction_id(PK), account_id, type(credito|debito), amount_cents, ref_type(invoice|payment|ajuste), ref_id, date

ğŸ“Š CO â€” Controladoria & Dashboard (negÃ³cio)

co_cost_center: tenant_id, cc_id(PK), name, parent_cc_id?, is_active

co_fiscal_period: tenant_id, period_id(PK), start_date, end_date, status

co_kpi_definition: tenant_id, kpi_key(PK), name, unit, description?

co_kpi_snapshot: tenant_id, kpi_key, snapshot_at, value_number numeric, meta_json text (PK composta tenant_id, kpi_key, snapshot_at)

co_dashboard_tile: tenant_id, tile_id(PK), kpi_key, title, subtitle?, order_index, color?, is_active

ğŸ›ï¸ Customizings / Setup por mÃ³dulo

Tabelas de setup (*_setup) + listas definidas pelo usuÃ¡rio (*_def).
Usadas pelas telas de Setup (chips/selects/switches) e validadas no backend.

MM â€” Materiais

mm_setup: default_payment_terms int, default_currency, default_wh_id, require_mat_type bool, require_mat_class bool, allow_zero_price bool, default_uom

mm_category_def: category, is_active

mm_classification_def: classification, is_active

mm_price_channel_def: channel, is_active

mm_currency_def: currency, is_active

mm_vendor_rating_def: rating, is_active

mm_status_def: object_type(material|purchase_order|receiving), status, description?, is_final bool, order_index int

WH â€” DepÃ³sitos

wh_setup: default_plant_id, reserve_policy(no_backorder|allow_backorder), negative_stock_allowed bool, picking_strategy(fifo|lifo)

wh_inventory_status_def (opcional): status(good|damaged|hold), is_active

SD â€” Vendas

sd_setup: backorder_policy(block|allow|partial), pricing_mode(material|price_list), default_channel, auto_reserve_on_confirm bool

sd_order_status_def: status, description?, is_final bool, order_index int

sd_shipment_status_def: status, description?, is_final bool, order_index int

sd_carrier_def: carrier_code, carrier_name, is_active

sd_channel_def: channel, is_active

CRM â€” Leads

crm_setup: require_contact_info bool, auto_convert_on_first_order bool

crm_source_def: source, is_active

crm_lead_status_def: status, description?, order_index int, is_final bool

crm_opp_stage_def: stage, description?, order_index int, is_final bool

FI â€” Financeiro

fi_setup: currency, tax_inclusive bool, default_ar_account_id?, default_ap_account_id?, rounding_policy(bankers|up|down)

fi_payment_method_def: method, display_name, is_active

fi_payment_terms_def: terms_code, description?, days int, is_active

fi_tax_code_def (opcional): tax_code, description?, rate_bp int

CO â€” Controladoria

co_setup: timezone, kpi_refresh_cron

ğŸ” SeguranÃ§a (RLS & permissÃµes)

Habilitar RLS em todas as tabelas novas.

Policies padrÃ£o:

SELECT: tenant_id = current_setting('request.jwt.claims', true)::json->>'tenant_id'

INSERT/UPDATE/DELETE: mesma checagem em USING e WITH CHECK.

role_permission controla UI (nÃ£o substitui RLS):
resource: mm_material, mm_purchase_order, sd_sales_order, sd_shipment, fi_invoice, crm_lead, co_* etc.
action: read|create|update|delete|approve|receive|confirm|ship.

ğŸ”€ Fluxos principais & APIs (Edge Functions)

Todas as funÃ§Ãµes recebem/retornam JSON. AutenticaÃ§Ã£o por Supabase JWT.
PadrÃ£o de contrato: { ok: boolean, data?, error? }.
PaginaÃ§Ã£o: ?limit=&offset=. Nunca retornar coleÃ§Ãµes sem paginaÃ§Ã£o.

Setup (para cada mÃ³dulo)

GET /setup/:module â†’ { setup, defs: {...} }

POST /setup/:module â†’ upsert em *_setup

POST /setup/:module/def/:entity â†’ create; PUT/DELETE idem

Compras (MM/WH)

POST /po/create â†’ cria mm_purchase_order + itens; gera mm_order via doc_numbering

POST /po/approve â†’ muda status conforme mm_status_def

POST /po/receive â†’ grava em mm_receiving, atualiza wh_inventory_balance (on_hand += qty), opcional: ledger IN

Vendas (SD/WH/FI)

POST /so/create â†’ cria sd_sales_order + itens (doc_numbering)

POST /so/confirm â†’ se sd_setup.auto_reserve_on_confirm, reserva saldo (reserved += qty), checando backorder_policy

POST /shipment/ship â†’ baixa estoque (on_hand -= qty, reserved -= qty se havia), atualiza sd_shipment.status

POST /payment/confirm â†’ cria fi_invoice (se nÃ£o existir), fi_payment e fi_transaction (crÃ©dito ou dÃ©bito)

KPIs (CO)

POST /kpi/refresh (agendado) â†’ escreve co_kpi_snapshot para:

kpi_orders_today

kpi_month_revenue_cents

kpi_active_leads

kpi_stock_critical_count

ObservaÃ§Ãµes de consistÃªncia

Todas as mutaÃ§Ãµes de estoque devem ser transacionais (BEGIN/COMMIT).

wh_warehouse: garantir uma is_default=true por tenant (constraint parcial e validaÃ§Ã£o na funÃ§Ã£o).

next_doc_number deve fazer UPDATE â€¦ SET next_seq = next_seq+1 RETURNING para evitar colisÃ£o.

ğŸŒ± Seeds mÃ­nimos (exemplos)

tenant: LaplataLunaria

user_profile: 1 admin (UUID do Supabase)

doc_numbering: SO/MM/SH/PAY/INV com YYYYMM-SEQ6

wh_warehouse: plant_id=GOIANIA, is_default=true

mm_setup/sd_setup/crm_setup/fi_setup/co_setup: linhas default

Def tables:

MM: category(brinco, colar), classification(prata), currency(BRL), vendor_rating(A,B,C), status(material: active,draft,archived; purchase_order: draft,approved,received,cancelled)

SD: order_status(draft,confirmed,shipped,invoiced,delivered,cancelled), shipment_status(pending,partial,complete,cancelled), carrier(correios,jadlog), channel(site,whatsapp)

CRM: source(instagram,whatsapp,site), lead_status(novo,em_contato,qualificado,convertido), opp_stage(discovery,validation,closing)

FI: payment_method(pix,cartao,boleto), payment_terms(NET30=30d)

CO: tiles 1â€“4 apontando para KPIs do topo

Dados de negÃ³cio de exemplo:

Fornecedor SUP_00001, Material BR-001, DepÃ³sito WH-001 (default), Saldo on_hand=100

Cliente CUST-0001, SO SO-YYYYMM-000001 com 1 item

Conta FI ACC-0001 (Banco)

ğŸ§ª ValidaÃ§Ãµes de negÃ³cio (must-have)

MM Material: se mm_setup.require_mat_type, mm_mat_type nÃ£o nulo; mm_mat_type âˆˆ mm_category_def.active.

Purchase Order: status deve pertencer a mm_status_def(object_type='purchase_order') e seguir ordem (enforce por app/EF).

Reserva/Backorder: respeitar sd_setup.backorder_policy (block/allow/partial).

Warehouse Default: impedir mÃºltiplos is_default=true por tenant (constraint).

Pagamentos/Faturas: fi_payment_terms_def.days preenche due_date ao emitir fatura.

ğŸ§± Ãndices & Performance (Free Tier)

Ãndices compostos:

ON mm_purchase_order_item(tenant_id, mm_order)

ON mm_receiving(tenant_id, mm_order)

ON wh_inventory_balance(tenant_id, plant_id, mm_material) UNIQUE

ON sd_sales_order_item(tenant_id, so_id)

ON co_kpi_snapshot(tenant_id, kpi_key, snapshot_at DESC)

PaginaÃ§Ã£o sempre (limit 50 default).

FunÃ§Ãµes leves: nada de loops por toda a base; usar queries agregadas e snapshots para dashboards.

Cache: no frontend, TanStack Query com staleTime 30â€“120s para listas estÃ¡veis.

Cron KPI: no free da Supabase, rodar a cada 15 min.

ğŸ§° Build & Deploy (Vercel Ready)
Vercel

Framework preset: Next.js

Build command: npm run build

Output: .next

Branch de produÃ§Ã£o: erp-prod

Branch de preview: erp-dev, erp-git

Images: otimizadas automaticamente

Env: NEXT_PUBLIC_* para frontend; SUPABASE_SERVICE_ROLE_KEY para Edge Functions.

Dynamic SSR: Todas as pÃ¡ginas com `export const dynamic = 'force-dynamic'`.

API Routes: Todas com `export const dynamic = 'force-dynamic'` e `runtime = 'nodejs'`.

Supabase

Rodar migraÃ§Ãµes (supabase/migrations) e depois seeds (supabase/seed).

Publicar Edge Functions (supabase functions deploy â€¦) para: setup_*, po, so, shipment, payment, kpi_refresh.

Habilitar RLS em todas as tabelas novas e aplicar policies padrÃ£o por tenant.

GitHub

RepositÃ³rio com monorepo simples (frontend + supabase + docs).

CI opcional: lint + typecheck (sem build pesado para nÃ£o estourar minutos do free).

ğŸ§¯ LiÃ§Ãµes aprendidas incorporadas (do relatÃ³rio de falhas)

DependÃªncias: travar versÃµes principais (Next 14.0.x, React 18). Evitar libs abandonadas; remover pacotes nÃ£o usados.

Scripts de import: consolidar em uma EF de bootstrap com validaÃ§Ã£o; logs em import_job/log.

PadronizaÃ§Ã£o de campos: nomes canÃ´nicos (ex.: mm_material, plant_id, so_id, mm_order), todos em snake_case.

VariÃ¡veis de ambiente: usar somente NEXT_PUBLIC_* no front; checagens no next.config.js foram removidas (No more "invalid next.config env").

Bundle Frontend: lazy-load nas pÃ¡ginas de mÃ³dulos; evitar Ã­cones/packs gigantes.

Queries: todas as tabelas com Ã­ndices Ãºteis + paginaÃ§Ã£o.

ğŸ” RLS (Row Level Security) e Bypass para Desenvolvimento:

RLS habilitado em todas as tabelas com polÃ­ticas por tenant_id.

Desenvolvimento local: AUTH_DISABLED=true permite bypass do RLS usando SUPABASE_SERVICE_ROLE_KEY.

Service role key: deve ser usado apenas no backend para bypassar RLS quando necessÃ¡rio.

PolÃ­ticas RLS: verificam current_setting('request.jwt.claims', true)::json->>'tenant_id'.

Bypass automÃ¡tico: quando AUTH_DISABLED=true, usar createClient() diretamente com service role key.

ğŸ”§ Guardrails e Qualidade de CÃ³digo:

Pre-commit hooks: verificam arquivos crÃ­ticos antes do commit.

Preflight script: valida porta, autenticaÃ§Ã£o, banco de dados e TypeScript.

SincronizaÃ§Ã£o automÃ¡tica: script para commit e push com exclusÃ£o de .env.local.

DocumentaÃ§Ã£o de mudanÃ§as: change-intent.json para alteraÃ§Ãµes crÃ­ticas de schema.

âœ… Checklists de verificaÃ§Ã£o
ApÃ³s migraÃ§Ãµes

 wh_warehouse: exatamente 1 is_default=true por tenant

 RLS habilitada em todas as tabelas novas

 doc_numbering com SO/MM/SH/PAY/INV ativos

ApÃ³s seeds

 mm_*_def, sd_*_def, crm_*_def, fi_*_def preenchidos

 tiles CO configurados (4 KPIs do topo)

 1 fornecedor, 1 material, 1 depÃ³sito (default), 1 cliente

ApÃ³s publicar Edge Functions

 GET /setup/mm retorna setup + defs

 POST /po/create cria PO e itens; receive atualiza estoque

 POST /so/confirm reserva saldo conforme polÃ­tica

 POST /shipment/ship dÃ¡ saÃ­da de estoque

 POST /payment/confirm cria invoice/payment/transaction

 POST /kpi/refresh grava snapshots

Vercel

 VariÃ¡veis NEXT_PUBLIC_* setadas para Production e Preview

 Build aponta para .next

 Branch de produÃ§Ã£o = erp-prod

 Branch de preview = erp-dev, erp-git

 Deploy automÃ¡tico configurado

 GitHub Workflows para controle de deploys

ğŸ§© Componentes/base de cÃ³digo a gerar

<KpiCard /> (valor + comparativo pequeno)

<ModuleTile /> (card com links)

DataTable com paginaÃ§Ã£o server-side

Forms (shadcn) para CRUD de material, fornecedor, cliente, PO/SO

PÃ¡ginas Setup para todos os mÃ³dulos (chips/listas/seletores gravando nas tabelas *_def/*_setup)

ğŸ”š ObservaÃ§Ãµes finais

Este documento Ã© a fonte Ãºnica da verdade para gerar migrations, seeds, Edge Functions e pÃ¡ginas.

Priorize MVP funcional (ciclos: Compraâ†’Recebimentoâ†’Estoque e Vendaâ†’ExpediÃ§Ã£oâ†’Pagamento).

Mantenha a compatibilidade com planos free: nada de rotas sem paginaÃ§Ã£o, nada que varra a base inteira, KPIs por snapshot.

Pronto. Gere a implementaÃ§Ã£o respeitando fielmente este blueprint.